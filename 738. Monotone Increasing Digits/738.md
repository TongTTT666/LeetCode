# Monotone Increasing Digits # 

Given a non-negative integer `N`, find the largest number that is less than or equal to `N` with monotone increasing digits.

(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits `x` and y satisfy `x <= y`.)

**Example 1:**
```
Input: N = 10
Output: 9
```
**Example 2:**
```
Input: N = 1234
Output: 1234
```
**Example 3:**
```
Input: N = 332
Output: 299
```
Note: `N` is an integer in the range `[0, 10^9]`.

---
## 解题思路 ##
这个题目用greedy算法就可以处理，但是要注意特殊情况，最通俗的情况时没有重复数字的，例如数字2746。对于数字2746我们需要不断判断前一位的数字是否比后一位数字小于或等于，如果满足就不做变化，如果不满足，就把该位减1，后面所有数字置位9：
```
2746 -> 7比2大 -> 1746(该位减1) -> 1999(后面位全变9)
```
再举一个例子，例如2476：
```
2476 -> 2比4小 -> 2476 -> 4比7小 -> 2476 -> 7比6大 -> 2466(该位减1) -> 2469(后面位全变9)
```
但这种减1再遇到下面这种操蛋情况的时候就不行了，比如887，刚开始判断8等于8，按兵不动，再判断8大于7了，按上面的操作，8应该减1变成7，然后把7变成9，也即887->879。很明显，这个完全不对啊！7又小于8了，这个1是万万不能减的！因此，这种贪心算法是不完备的，我们还必须考虑这种一大堆数字重复的情况。

很明显，887应该变成799，因此采用以下策略，一旦出现数字相等，我们就把第一个开始重复的位数记下来，例如887中对应的是第一位“8”，再往后判断，7小于8，不符合要求，那么我们就把重复的第一位减1，也即887->787，接着把后面都变成9就行了，也即787->799。因此，遇到一大堆数字重复的情况，**记录重复数字的第一位，如果出现了某一位小于前面一大堆重复数字的情况，就把重复数字的第一位减1，后面所有位全部变成9即可**。经测试证明，这种贪心策略是完备的，如果遇到88888887或者88888889这两种情况，会返回79999999和88888889。


