# Longest Palindromic Substring #
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

**Example:**
```
Input: "babad"

Output: "bab"

Note: "aba" is also a valid answer.
```
 
**Example:**
```
Input: "cbbd"

Output: "bb"
```
---
## 解题思路 ##
这个题和算法作业那道回文cut题非常类似，传统的动态规划需要O(n^3)的时间，转换思路可以将速度提升至O(n^2)。传统的动态规划算法是定一个末尾，用一个指针搜索前面所有可能的字符串，判断是否组成最大回文。此时，至少需要两个for循环，再加上判断回文还需要一个for循环，一共是三个for循环，十分费时间。

然而，如果我们把定末尾变成**定回文中心**，则问题变得非常简单。假设确定了字符串中s[i]为回文中心，那么，我们只需要分以s[i]为中心的回文字符串是奇数长度还是偶数长度两种情况讨论即可。如果是奇数长度，那么s[i]就是中心；如果是偶数长度，那么s[i]和s[i+1]共同组成回文中心（说到这感觉很像之前那道中位数的题）。 **定死s[i]为中心后，最长回文字符串一定是唯一的！！！再说一次！！！一定是唯一的！！！**也即，以s[i]为中心一定有且仅能找到一个最长回文字符串！！！

那么，究竟该如何取找这个字符串了？中心我们都确定了，那么就分奇偶情况，利用**双指针**骚操作来处理！
- 对于奇数情况，双指针刚开始都指向s[i]，我们令双指针一个为k1一个为k2。接着，k1指针往i-1方向移动，k2指针往i+1方向移动，判断s[k1:k2+1]（python语法）是否为回文（其实只用反复验证s[k1]是否等于s[k2]即可），如果是的话就继续按上述方向移动指针。如果当前回文的长度已经大于了最大长度，那么就更新最大长度以及回文字符串的起点和终点。如果某处已经出现了两个指针所夹中间字符串不是回文了，也即出现了s[k1]不等于s[k2]的情形，我们把当前的循环break掉，因为再往后推已经没有意义了，就算后面又出现了s[k1]==s[k2]的情况，也无济于事了，这种没有意义的循环要省略掉。
- 对于偶数情况，就很类似了，唯一的区别是双指针刚开始一个指向s[i]一个指向s[i+1]，后面用跟上述一样的骚操作就行！


## Trick ##
- 如果可以不用字符或者数组赋值，尽量不用，可以大幅提升算法运行时间。
- 某些不用循环的情况可以手动排除（具体见代码），这样可以节省大量时间！
