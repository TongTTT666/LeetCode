# Jump Game #

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:
A = `[2,3,1,1,4]`, return `true`.

A = `[3,2,1,0,4]`, return `false`. 

---

## 解题思路 ##
这个题目我的思路相比大神思路的实现办法速度还要快一些，这主要是因为测试集中的0比较少，所以相比之下会比较快，下面针对两种思路做简要介绍：

### 大神的思路： ###

大神的思路非常直观，对于每一个节点我们均判断一次能到达的最大位置。举例说明：例如[1,2,1,3,0,1]，对于节点0，我们认为其最大能走到节点1(0+1)；对于节点1，我们认为其最大能走到节点3(1+2)。将这两个可达到位置取最大值，我们可以得出当前能够走到的最远距离是节点3。按这个思路不断分析，如果某个节点的编号已经大于了之前所有节点分析得出的最大可达位置，则该节点不可能达到，终止算法，返回不可能。如果遍历所有节点都没有终止算法，则返回可以。

### 自己的思路： ###

我的思路是最显然的，这个题目唯一的障碍就是值为0的节点（因为值为0意味着这个一旦走到这个节点则无法动弹），从这些节点突破一定能够得到不错的效果，尤其是当0较少的时候。对于每一个0位置，遍历前面所有节点，看这个值为0的节点是否能够被跨过去。举例说明，如果出现[3,2,1,0,1]，则这个0元素是没法跨过去的。在算法中，我们先遍历数组，发现0元素后，遍历0元素前面所有的数，看nums[i]+i是否大于0元素的位置，一旦发现存在大于情况说明第i个节点跳nums[i]步可以越过这个障碍，该障碍不存在，或者说该障碍可以被我越过去。如果遍历所有前面的节点，都找不到一个合适的节点i，是使得nums[i]+i大于0元素的位置，则障碍无法越过，直接返回不可能。如果遍历到最后一个节点算法都没有停止，则返回可以。