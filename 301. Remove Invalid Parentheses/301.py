class Solution:
    def removeInvalidParentheses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        
        
        # par = ['(', ')']是一对，通用性非常强的算法
        def helper(s, ans, last_i, last_j, par):
            dif = 0
            # 第一步，我们只看多余的')'，把你干掉，对于多余的'('我们后面再处理
            for i in range(last_i, len(s)):
                # 计算左括号和右括号数目，一旦右括号比左括号多，立刻进行删除！！！
                # 说明当前字符串必定要删除多余的')'
                dif += (s[i] == par[0]) - (s[i] == par[1])
                if dif < 0:
                    # s[0:i]出现了多余的')'，需要立即删除！！！
                    # 但是删除哪一个呢？我们规定删除第一个！
                    # 现在我们就来找这个第一个多余的')'
                    for j in range(last_j, i+1):
                        if s[j] == par[1] and (j == last_j or s[j-1] != par[1]):
                            # 把多余的那个')'去掉，形成新字符串进行迭代
                            # 这个地方有一个技巧，因为这只有i循环中的一次删除过程
                            # 所以能够包括了所有的删除情况，也即递归调用（删除）完成后，
                            # 剩余字符串还会回到第一个i循环上去继续运行
                            # 第二个技巧：由于及时删除了多余的')'，递归调用中
                            # 的i循环直接从上一轮的i开始即可(last_i)，纯属节省时间，因为
                            # s[0:i]中的多余')'已经被删除了，一定满足条件，不需要再进行循环
                            helper(s[:j] + s[j+1:], ans, i, j, par)
                    # 这个return非常关键！处理完多余的'('立刻跳出函数！！！！！！！
                    # 除非你进入不了j循环，也即不存在dif < 0的情况，也即不存在多余的')'时，
                    # 我们才能够处理多余的'('，一个干完再干另外一个！
                    return
           
            # ')'已经被处理过了，下面要处理多余的'('了！
            # 根据对称关系，我们只需要把原字符串和par反向！就可以了！这个太神了！！！
            # 开始反向！
            reversed_s = s[::-1]
            # 这个判断是为了确认当前是处理')'的问题，还是处理'('时进入的函数
            # 如果是在此时进入的helper函数，par[0]应该是')'！！！也即开始处理')'了
            if par[0] == '(':
                # 对反向字符串再重新怼一次！
                helper(reversed_s, ans, 0, 0, [')','('])
            else:
                # 处理完了')'就是最后的结果啊！
                ans.append(reversed_s)
        
        # 主函数部分
        ans = []
        helper(s, ans, 0, 0, ['(', ')'])
        return ans
                
            
                
                            
                            
                            
                            