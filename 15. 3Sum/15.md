# 3Sum #


Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:** The solution set must not contain duplicate triplets.
```
For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
---

## 解题思路 ##
本题也是一个特别经典的题型，利用双指针进行操作。在做算法题的时候需要具备以下意识，如果涉及三个数（或者是什么其他的东西）的选取，我们采取**定1变2**的策略，也即确定一个数，用两个可变指针指向其他两个待选取的数，然后用循环判断目标是否满足，满足就将这三个数加入到结果中，不满足就调整两个可变指针的位置接着继续判断。

在做本题的时候，由于选取的数字不要求顺序，因此我们直接对原数组进行升序排序，然后才可以利用双指针进行操作。在本题中，我们通过确定三个数中的最小数，也即第一个数，根据验证结果调整两个指针left和right的位置，满足题目要求就加入结果list中。其中，left指针只能右移，right指针只能左移，这是为了避免重复。

我们还是以S = [-1, 0, 1, 2, -1, -4]作为例子，初始化情形：
```
S = [-1, 0, 1, 2, -1, -4]
先排序
S = [-4, -1, -1, 0, 1, 2]
初始化第一个数i以及两个指针的位置
S = [-4, -1, -1, 0, 1, 2]
     |    |            |
     i   left         right
判断：-4 + -1 + 2 = -3 < 0，因此太小了，我们需要调大数字，只能通过右移left指针实现，也即
S = [-4, -1, -1, 0, 1, 2]
     |        |        |
     i      left     right
判断：-4 + -1 + 2 = -3 < 0，继续移动left指针
...省略几步，直到
S = [-4, -1, -1, 0, 1, 2]
     |              |  |
     i            left right
判断：我们发现此时-4 + 1 + 2 = -1 < 0，我们已经别无选择，left指针再往右移都已经无法满足三个数的要求，因此我们只能进入下面一个循环，将-1置位最小的数，并初始化：
S = [-4, -1, -1, 0, 1, 2]
          |   |        |
          i  left    right
判断：-1 + -1 + 2 = 0，满足要求，加入到结果中。当满足结果的时候我们还需要避免重复数字，比如对于left来说可能存在若干个连续的-1，对于right来说可能存在若干个重复的2（此例中未出现），我们需要通过while循环跳过这些重复的数字，直至left和right指向一个新的数字，也即:
S = [-4, -1, -1, 0, 1, 2]
          |      |  |
          i    left right
判断：-1 + 0 + 1 = 0，满足要求，加入到结果中。但left和right指针都没法继续移动了，必须满足left < right的要求，这也是满足不重复的一个前提。如果left > right，那么实际上left和right的职能就对调了，一定出现了重复的情形；如果left = right，则不满足三个数的要求。
```
接着，我们要进入下一步的初始化过程，此处非常关键！！！**为了避免重复情况！定1过程也不能重复！！！一个相同的数只能被指定为1次最小的数，如果出现重复情况，必须跳过后面重复的数！！！**例如：
```
S = [-4, -1, -1, 0, 1, 2]
          |      |  |
          i    left right
的下一步，按理来说应该初始化为：
S = [-4, -1, -1, 0, 1, 2]
              |  |     |
              i left right
但此时的开头数字还是-1，这也就意味着我们经过验证-1 + 0 + 2 > 0，由于大于0，所以我们应当把数字减小，右移right指针就可以做到：
S = [-4, -1, -1, 0, 1, 2]
              |  |  |
             i left right
此时-1 + 0 + 1满足情况，但-1, 0, 1已经出现过一次了！！！也就是说出现了重复情形！！！不满足题目要求！！！这就是因为我两次都选择了-1作为最小数字，必定存在重复的情形，第一次遇到-1的时候我已经针对-1做完了所有的情况！没有必要再重复做了！因此，遇到重复数作为最小数的情形，我们只做第一个数，后面的数直接跳过。但如果你直接做后面的-1，而不做前面的-1，是一定会丢失情况的，比如[-1, -1, 2]，所以遇到重复数必须做第一个数！
```

最后，还有一些小技巧，比如不符合要求的滚蛋，符合题目要求不论是否出现重复元素，第1个数字都必须作为最小数做一次等等，这个就自己发掘吧！！！