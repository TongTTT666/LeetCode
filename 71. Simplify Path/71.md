# Simplify Path #

Given an absolute path for a file (Unix-style), simplify it.

For example,

`path = "/home/", => "/home"`

`path = "/a/./b/../../c/", => "/c"`


Corner Cases:

- Did you consider the case where path = `"/../"`?
    
    In this case, you should return `"/"`. 

- Another corner case is the path might contain multiple slashes `'/'` together, such as `"/home//foo/"`. In this case, you should ignore redundant slashes and return `"/home/foo"`.

---

## 解题思路 ##
这是一道路径化简为题，如果你对文件路径有了解就极其简单，但如果不了解根本做不出来的题。这个题目题干叙述的完全不明确，需要补充一下常识才能做：
1. 路径是以`'/'`符号位分割单元的，因此我们在编程的时候要充分利用这个性质，要将path按照`'/'`分割成几个子部分去分析，切记不可遍历path！
2. 如果存在单点（也即`'.'`），那么该单点可以忽略掉，相当于其不存在。
3. 如果存在双点（也即`'..'`），则该双点以及它前面的一个部分一起删去。
4. 多个`'/'`只能保留一个。
6. 其他部分正常保留。
7. 接着以`'/'`为分隔符把上述的分离部分再组成一个字符串，注意开头要加一个额外的`'/'`。
8. 如果按上述法则求出的字符串长度为0，则直接返回`'/'`。

为了更加形象的说明上述过程，我们举一个实际的例子来说明这个流程：
```
如果path = "/a/./b/../../c/"，首先按'/'分割部分，为'a','.','b','..','..','c'。按照上述法则，我们要把单点'.'忽略掉，也即实际的有效分割部分为'a','b','..','..','c'。接着，我们把第一个双点'..'和其前面部分'b'忽略掉，变成'a','..','c'。我们会发现，还存在一个双点，我们还是重复上述操作，删去这个双点和其前面的部分，也即最后的有效分割部分为：'c'。最后我们以'/'为分隔符重组有效分割部分，并在最前面加上一个'/'，即可得到'/c'，与上述例子相同。
```
把这个流程弄清楚了，问题就非常简单了，用python语言将字符串分割成字符串list，去掉'.'的部分。接着遍历list，选出有效分割部分，如果发现'..'，就把上一个选入有效分割部分的字符串`pop`掉，如果不是'..'就把当前字符串`append`进有效分割部分。最后，把有效分割用`'/' + '/'.join(stack)`操作完成即可。

需要分别说明的是自己一直没有理解的`join`函数，该函数`'.'`前面的那个字符是分割符，`join`函数的输入是一个字符串list，用这个操作可以把字符串list按每一个元素间隔分隔符的形式组成字符串，例如
```python
a = ["I", "am", "Tong", "Tong"]
print('/'.join(a))
可以得到：
"I/am/Tong/Tong"
```